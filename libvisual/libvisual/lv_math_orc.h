
/* autogenerated from lv_math.orc */

#ifndef _LV_MATH_ORC_H_
#define _LV_MATH_ORC_H_

#include <math.h>

#ifdef __cplusplus
extern "C" {
#endif



#include <orc/orc.h>

static inline void
simd_mul_floats_float (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_mul_floats_float");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_parameter_float (p, 4, "p1");

      orc_program_append_2 (p, "mulf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}
static inline void
simd_mul_floats_floats (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, const float * ORC_RESTRICT s2, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_mul_floats_floats");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_source (p, 4, "s2");

      orc_program_append_2 (p, "mulf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_S2, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  ex->arrays[ORC_VAR_S2] = (void *)s2;

  func = c->exec;
  func (ex);
}
static inline void
simd_add_floats_float (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_add_floats_float");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_parameter_float (p, 4, "p1");

      orc_program_append_2 (p, "addf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}
static inline void
simd_floats_to_int32s (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_floats_to_int32s");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");

      orc_program_append_2 (p, "convfl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;

  func = c->exec;
  func (ex);
}
static inline void
simd_int32s_to_floats (float * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_int32s_to_floats");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");

      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;

  func = c->exec;
  func (ex);
}
static inline void
simd_sqrt_floats (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_sqrt_floats");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");

      orc_program_append_2 (p, "sqrtf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;

  func = c->exec;
  func (ex);
}
static inline void
simd_floats_to_int32s_mul_float (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_floats_to_int32s_mul_float");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_parameter_float (p, 4, "p1");
      orc_program_add_temporary (p, 4, "t1");

      orc_program_append_2 (p, "convfl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_D1, ORC_VAR_P1, ORC_VAR_T1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}
static inline void
simd_int32s_to_floats_mul_float (float * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_int32s_to_floats_mul_float");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_parameter_float (p, 4, "p1");
      orc_program_add_temporary (p, 4, "t1");

      orc_program_append_2 (p, "convlf", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_D1, ORC_VAR_P1, ORC_VAR_T1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}
static inline void
simd_complex_norm (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, const float * ORC_RESTRICT s2, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_complex_norm");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_source (p, 4, "s2");
      orc_program_add_temporary (p, 4, "t1");
      orc_program_add_temporary (p, 4, "t2");

      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_S1, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_S2, ORC_VAR_D1);
      orc_program_append_2 (p, "addf", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
      orc_program_append_2 (p, "sqrtf", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  ex->arrays[ORC_VAR_S2] = (void *)s2;

  func = c->exec;
  func (ex);
}
static inline void
simd_complex_scaled_norm (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, const float * ORC_RESTRICT s2, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_complex_scaled_norm");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_source (p, 4, "s2");
      orc_program_add_parameter_float (p, 4, "p1");
      orc_program_add_temporary (p, 4, "t1");
      orc_program_add_temporary (p, 4, "t2");

      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_S1, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_S2, ORC_VAR_D1);
      orc_program_append_2 (p, "addf", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
      orc_program_append_2 (p, "sqrtf", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_P1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  ex->arrays[ORC_VAR_S2] = (void *)s2;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}
static inline void
simd_denorm_floats_to_int32s (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_denorm_floats_to_int32s");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_constant (p, 4, 0x00000000, "c1");
      orc_program_add_constant (p, 4, 0x3f800000, "c2");
      orc_program_add_parameter_float (p, 4, "p1");
      orc_program_add_temporary (p, 4, "t1");
      orc_program_add_temporary (p, 4, "t2");

      orc_program_append_2 (p, "maxf", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_C1, ORC_VAR_D1);
      orc_program_append_2 (p, "minf", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C2, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_P1, ORC_VAR_D1);
      orc_program_append_2 (p, "convfl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}
static inline void
simd_denorm_neg_floats_to_int32s (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
{
  OrcExecutor _ex, *ex = &_ex;
  static int p_inited = 0;
  static OrcCode *c = 0;
  void (*func) (OrcExecutor *);

  if (!p_inited) {
    orc_once_mutex_lock ();
    if (!p_inited) {
      OrcProgram *p;

      p = orc_program_new ();
      orc_program_set_name (p, "simd_denorm_neg_floats_to_int32s");
      orc_program_add_destination (p, 4, "d1");
      orc_program_add_source (p, 4, "s1");
      orc_program_add_constant (p, 4, 0xbf800000, "c1");
      orc_program_add_constant (p, 4, 0x3f800000, "c2");
      orc_program_add_constant (p, 4, 0x3f000000, "c3");
      orc_program_add_parameter_float (p, 4, "p1");
      orc_program_add_temporary (p, 4, "t1");
      orc_program_add_temporary (p, 4, "t2");

      orc_program_append_2 (p, "maxf", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_C1, ORC_VAR_D1);
      orc_program_append_2 (p, "minf", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C2, ORC_VAR_D1);
      orc_program_append_2 (p, "addf", 0, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_C2, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C3, ORC_VAR_D1);
      orc_program_append_2 (p, "mulf", 0, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_P1, ORC_VAR_D1);
      orc_program_append_2 (p, "convfl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);

      orc_program_compile (p);
      c = orc_program_take_code (p);
      orc_program_free (p);
    }
    p_inited = TRUE;
    orc_once_mutex_unlock ();
  }
  ex->arrays[ORC_VAR_A2] = c;
  ex->program = 0;

  ex->n = n;
  ex->arrays[ORC_VAR_D1] = d1;
  ex->arrays[ORC_VAR_S1] = (void *)s1;
  {
    orc_union32 tmp;
    tmp.f = p1;
    ex->params[ORC_VAR_P1] = tmp.i;
  }

  func = c->exec;
  func (ex);
}

#ifdef __cplusplus
}
#endif

#endif

